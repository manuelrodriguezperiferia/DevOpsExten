{"version":3,"sources":["../src/use-chat.ts","../src/use-completion.ts"],"sourcesContent":["import type {\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  JSONValue,\n  Message,\n  UseChatOptions,\n} from '@ai-sdk/ui-utils';\nimport {\n  callChatApi,\n  generateId as generateIdFunc,\n  processChatStream,\n} from '@ai-sdk/ui-utils';\nimport { Accessor, Resource, Setter, createSignal } from 'solid-js';\nimport { useSWRStore } from 'solid-swr-store';\nimport { createSWRStore } from 'swr-store';\n\nexport type { CreateMessage, Message, UseChatOptions };\n\nexport type UseChatHelpers = {\n  /** Current messages in the chat */\n  messages: Resource<Message[]>;\n  /** The error object of the API request */\n  error: Accessor<undefined | Error>;\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   * @param options Additional options to pass to the API call\n   */\n  append: (\n    message: Message | CreateMessage,\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: (\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n  /**\n   * Update the `messages` state locally. This is useful when you want to\n   * edit the messages on the client, and then trigger the `reload` method\n   * manually to regenerate the AI response.\n   */\n  setMessages: (messages: Message[]) => void;\n  /** The current value of the input */\n  input: Accessor<string>;\n  /** Signal setter to update the input value */\n  setInput: Setter<string>;\n  /** Form submission handler to automatically reset input and append a user message */\n  handleSubmit: (e: any, chatRequestOptions?: ChatRequestOptions) => void;\n  /** Whether the API request is in progress */\n  isLoading: Accessor<boolean>;\n  /** Additional data added on the server via StreamData */\n  data: Accessor<JSONValue[] | undefined>;\n};\n\nlet uniqueId = 0;\n\nconst store: Record<string, Message[] | undefined> = {};\nconst chatApiStore = createSWRStore<Message[], string[]>({\n  get: async (key: string) => {\n    return store[key] ?? [];\n  },\n});\n\nexport function useChat({\n  api = '/api/chat',\n  id,\n  initialMessages = [],\n  initialInput = '',\n  sendExtraMessageFields,\n  experimental_onFunctionCall,\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body,\n  streamMode,\n  generateId = generateIdFunc,\n}: UseChatOptions = {}): UseChatHelpers {\n  // Generate a unique ID for the chat if not provided.\n  const chatId = id || `chat-${uniqueId++}`;\n\n  const key = `${api}|${chatId}`;\n\n  // Because of the `initialData` option, the `data` will never be `undefined`:\n  const messages = useSWRStore(chatApiStore, () => [key], {\n    initialData: initialMessages,\n  }) as Resource<Message[]>;\n\n  const mutate = (data: Message[]) => {\n    store[key] = data;\n    return chatApiStore.mutate([key], {\n      status: 'success',\n      data,\n    });\n  };\n\n  const [error, setError] = createSignal<undefined | Error>(undefined);\n  const [streamData, setStreamData] = createSignal<JSONValue[] | undefined>(\n    undefined,\n  );\n  const [isLoading, setIsLoading] = createSignal(false);\n\n  let abortController: AbortController | null = null;\n  async function triggerRequest(\n    messagesSnapshot: Message[],\n    { options, data }: ChatRequestOptions = {},\n  ) {\n    try {\n      setError(undefined);\n      setIsLoading(true);\n\n      abortController = new AbortController();\n\n      const getCurrentMessages = () =>\n        chatApiStore.get([key], {\n          shouldRevalidate: false,\n        });\n\n      // Do an optimistic update to the chat state to show the updated messages\n      // immediately.\n      const previousMessages = getCurrentMessages();\n      mutate(messagesSnapshot);\n\n      let chatRequest: ChatRequest = {\n        messages: messagesSnapshot,\n        options,\n        data,\n      };\n\n      await processChatStream({\n        getStreamedResponse: async () => {\n          const existingData = streamData() ?? [];\n\n          return await callChatApi({\n            api,\n            messages: sendExtraMessageFields\n              ? chatRequest.messages\n              : chatRequest.messages.map(\n                  ({\n                    role,\n                    content,\n                    name,\n                    data,\n                    annotations,\n                    function_call,\n                  }) => ({\n                    role,\n                    content,\n                    ...(name !== undefined && { name }),\n                    ...(data !== undefined && { data }),\n                    ...(annotations !== undefined && { annotations }),\n                    // outdated function/tool call handling (TODO deprecate):\n                    ...(function_call !== undefined && { function_call }),\n                  }),\n                ),\n            body: {\n              data: chatRequest.data,\n              ...body,\n              ...options?.body,\n            },\n            streamMode,\n            headers: {\n              ...headers,\n              ...options?.headers,\n            },\n            abortController: () => abortController,\n            credentials,\n            onResponse,\n            onUpdate(merged, data) {\n              mutate([...chatRequest.messages, ...merged]);\n              setStreamData([...existingData, ...(data ?? [])]);\n            },\n            onFinish,\n            restoreMessagesOnFailure() {\n              // Restore the previous messages if the request fails.\n              if (previousMessages.status === 'success') {\n                mutate(previousMessages.data);\n              }\n            },\n            generateId,\n          });\n        },\n        experimental_onFunctionCall,\n        updateChatRequest(newChatRequest) {\n          chatRequest = newChatRequest;\n        },\n        getCurrentMessages: () => getCurrentMessages().data,\n      });\n\n      abortController = null;\n    } catch (err) {\n      // Ignore abort errors as they are expected.\n      if ((err as any).name === 'AbortError') {\n        abortController = null;\n        return null;\n      }\n\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n\n      setError(err as Error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  const append: UseChatHelpers['append'] = async (message, options) => {\n    if (!message.id) {\n      message.id = generateId();\n    }\n    return triggerRequest(\n      (messages() ?? []).concat(message as Message),\n      options,\n    );\n  };\n\n  const reload: UseChatHelpers['reload'] = async options => {\n    const messagesSnapshot = messages();\n    if (!messagesSnapshot || messagesSnapshot.length === 0) return null;\n\n    const lastMessage = messagesSnapshot[messagesSnapshot.length - 1];\n    if (lastMessage.role === 'assistant') {\n      return triggerRequest(messagesSnapshot.slice(0, -1), options);\n    }\n    return triggerRequest(messagesSnapshot, options);\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setMessages = (messages: Message[]) => {\n    mutate(messages);\n  };\n\n  const [input, setInput] = createSignal(initialInput);\n\n  const handleSubmit = (e: any, options: ChatRequestOptions = {}) => {\n    e.preventDefault();\n    const inputValue = input();\n    if (!inputValue) return;\n\n    append(\n      {\n        content: inputValue,\n        role: 'user',\n        createdAt: new Date(),\n      },\n      options,\n    );\n\n    setInput('');\n  };\n\n  return {\n    messages,\n    append,\n    error,\n    reload,\n    stop,\n    setMessages,\n    input,\n    setInput,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n  };\n}\n","import type {\n  JSONValue,\n  RequestOptions,\n  UseCompletionOptions,\n} from '@ai-sdk/ui-utils';\nimport { callCompletionApi } from '@ai-sdk/ui-utils';\nimport { Accessor, Resource, Setter, createSignal } from 'solid-js';\nimport { useSWRStore } from 'solid-swr-store';\nimport { createSWRStore } from 'swr-store';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: Resource<string>;\n  /** The error object of the API request */\n  error: Accessor<undefined | Error>;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: RequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: Accessor<string>;\n  /** Signal Setter to update the input value */\n  setInput: Setter<string>;\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form onSubmit={handleSubmit}>\n   *  <input value={input()} />\n   * </form>\n   * ```\n   */\n  handleSubmit: (e: any) => void;\n  /** Whether the API request is in progress */\n  isLoading: Accessor<boolean>;\n  /** Additional data added on the server via StreamData */\n  data: Accessor<JSONValue[] | undefined>;\n};\n\nlet uniqueId = 0;\n\nconst store: Record<string, any> = {};\nconst completionApiStore = createSWRStore<any, string[]>({\n  get: async (key: string) => {\n    return store[key] ?? [];\n  },\n});\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamMode,\n  onResponse,\n  onFinish,\n  onError,\n}: UseCompletionOptions = {}): UseCompletionHelpers {\n  // Generate an unique id for the completion if not provided.\n  const completionId = id || `completion-${uniqueId++}`;\n\n  const key = `${api}|${completionId}`;\n  const data = useSWRStore(completionApiStore, () => [key], {\n    initialData: initialCompletion,\n  });\n\n  const mutate = (data: string) => {\n    store[key] = data;\n    return completionApiStore.mutate([key], {\n      data,\n      status: 'success',\n    });\n  };\n\n  // Because of the `initialData` option, the `data` will never be `undefined`.\n  const completion = data as Resource<string>;\n\n  const [error, setError] = createSignal<undefined | Error>(undefined);\n  const [streamData, setStreamData] = createSignal<JSONValue[] | undefined>(\n    undefined,\n  );\n  const [isLoading, setIsLoading] = createSignal(false);\n\n  let abortController: AbortController | null = null;\n\n  const complete: UseCompletionHelpers['complete'] = async (\n    prompt: string,\n    options?: RequestOptions,\n  ) => {\n    const existingData = streamData() ?? [];\n    return callCompletionApi({\n      api,\n      prompt,\n      credentials,\n      headers: {\n        ...headers,\n        ...options?.headers,\n      },\n      body: {\n        ...body,\n        ...options?.body,\n      },\n      streamMode,\n      setCompletion: mutate,\n      setLoading: setIsLoading,\n      setError,\n      setAbortController: controller => {\n        abortController = controller;\n      },\n      onResponse,\n      onFinish,\n      onError,\n      onData: data => {\n        setStreamData([...existingData, ...(data ?? [])]);\n      },\n    });\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setCompletion = (completion: string) => {\n    mutate(completion);\n  };\n\n  const [input, setInput] = createSignal(initialInput);\n\n  const handleSubmit = (e: any) => {\n    e.preventDefault();\n    const inputValue = input();\n    if (!inputValue) return;\n    return complete(inputValue);\n  };\n\n  return {\n    completion,\n    complete,\n    error,\n    stop,\n    setCompletion,\n    input,\n    setInput,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n  };\n}\n"],"mappings":"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","names":["data","messages","createSignal","useSWRStore","createSWRStore","uniqueId","store","data","completion"]}